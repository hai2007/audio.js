/*!
 * 🔇 audio.js - 🔇 前端处理音频的核心模块。 
 * git+https://github.com/hai2007/audio.js.git
 *
 * author 你好2007 < https://hai2007.gitee.io/sweethome >
 *
 * version 0.1.0
 *
 * Copyright (c) 2021-present hai2007 走一步，再走一步。
 * Released under the MIT license
 *
 * Date:Wed Oct 27 2021 23:01:06 GMT+0800 (GMT+08:00)
 */
(function(){"use strict";function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function(obj){return typeof obj}}else{_typeof=function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj}}return _typeof(obj)}var AudioContext=window.AudioContext||window.webkitAudioContext||window.mozAudioContext||window.msAudioContext;var AudioJS=function AudioJS(arrayBuffer){return new Promise((function(resolve,reject){var context=new AudioContext;context.decodeAudioData(arrayBuffer,(function(audioBuffer){var extractAudioBuffer=[];var audioJS={extract:function extract(beginTime,endTime){var channels=audioBuffer.numberOfChannels;var rate=audioBuffer.sampleRate;var startOffset=rate*beginTime;var endOffset=rate*endTime;var frameCount=endOffset-startOffset;var newAudioBuffer=(new AudioContext).createBuffer(channels,endOffset-startOffset,rate);var anotherArray=new Float32Array(frameCount);var offset=0;for(var channel=0;channel<channels;channel++){audioBuffer.copyFromChannel(anotherArray,channel,startOffset);newAudioBuffer.copyToChannel(anotherArray,channel,offset)}extractAudioBuffer.push(newAudioBuffer);return audioJS},play:function play(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:-1;var source=context.createBufferSource();source.buffer=index==-1?audioBuffer:extractAudioBuffer[index];source.connect(context.destination);source.start();return audioJS}};resolve(audioJS)}))}))};if((typeof module==="undefined"?"undefined":_typeof(module))==="object"&&_typeof(module.exports)==="object"){module.exports=AudioJS}else{window.AudioJS=AudioJS}})();